# Chargement libraries obligatoires
library(HTSFilter)
library(DESeq2)
library(edgeR)
library(limma)
library(topGO)
library(mixOmics)
library(gplots)
library(cluster)
# Chargment libraries non obligatoires
library(a4Base)
library(dplyr)
library(tidyr)
library(org.At.tair.db)
###############
# Lecture des données
# Pour chaque gène et chaque condition réplicat, on dispose de:
data_kin=read.table("data/data.kin.txt",header=T,sep='\t')
dim(data_in.out) #
# Chunk 1: setup
# les param du knit
#knitr::opts_chunk$set(fig.width=6, fig.height=4, echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
# les import
library(ape)
# Chunk 2
topoK = read.tree("Data/ComE_muscle_Kimura_tree.ph")
# Chunk 1: setup
# les param du knit
#knitr::opts_chunk$set(fig.width=6, fig.height=4, echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
# les import
library(ape)
# Chunk 2
topoK = read.tree("Data/ComE_muscle_Kimura_tree.ph")
layout(matrix(1:3,1,3))
col_tP <- codes[match(tableau[match(topoP$tip, tableau$Gene_Name), 12], codes[,1]), 2]
library(ade4)
library(knitr)
install.packages("ape")
library(ade4)
library(tidyverse)
# Chunk 1
knitr::opts_chunk$set(fig.align="center", fig.width=6, fig.height=6, fig.path="Figs/", echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
# Chunk 2
library(tidyverse)
library(ade4)
library(tidyverse)
library(ade4)
library(tidyverse)
library(ade4)
install.packages("ade4")
install.packages("~/Downloads/igraph_2.1.4.tar.gz", repos = NULL, type = "source")
library(tidyverse)
library(ade4)
library(tidyverse)
library(ade4)
install.packages(ade4)
knitr::opts_chunk$set(fig.align="center", fig.width=6, fig.height=6, fig.path="Figs/", echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
knitr::opts_chunk$set(fig.align="center", fig.width=6, fig.height=6, fig.path="Figs/", echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
```{r, include= F}
library(tidyverse)
library(ade4)
library(ade4)
habitat = read.table("../data/habitat.tsv", sep = "\t",
stringsAsFactors = T, header = T, na.strings = T)
especes = read.table("../data/especes.tsv", sep = "\t",
stringsAsFactors = T, header = T, na.strings = T)
commu = read.table("../data/communautes.tsv", sep = "\t", stringsAsFactors = T, header = T, na.strings = T)
habitat = habitat[,-2:-3]
habitat[,2:3] = habitat[,2:3]/1e5 ;# habitat[15] = habitat[15]/1e3
name = colnames(habitat)
name[2:3] = c("long/1e5","lat/1e5");# name[15] = "prec/1e3"
colnames(habitat) = name
habitat = habitat[,-2:-3]
ANALYSE :
####  ==> extraire informations précédentes = subset par colonnes dont on extrait les numéros des localisations
Création des subsets de numéro de lieu ayant des Gem (Colombe.a.croissants)
listSubsets = data.frame(matrix(nrow = length(vectNom), ncol = length(habitat[1,]) - 3))
listSubsets <- list()
for (i in 1:length(vectNom)) {
especesActu = vectNom[i]
foosubset = subset(commu$IdPE, commu[[i+1]] == 1)
listSubsets[[especesActu]] <- foosubset
}
listSubsets$Gem
listSubsets$Gem
On a toutes les localisation de chaque espèce
Exemple d'appel pour les localisation de Gem :
####  ==> moyenne des données sur l'habitat pour chaque colonne du subset (espèces)
Pour se donner une idée de vers ou on vas, nous allons regarder chaque moyenne de variables
```{r}
par(mfrow = c(1,1))
ExGem = colMeans(subset(habitat, habitat$IdPE %in% listSubsets$Gem))
plot(ExGem[-1])
par(mfrow = c(1,1))
ExGem = colMeans(subset(habitat, habitat$IdPE %in% listSubsets$Gem))
Généraliser par une boucle tapply :
```{r}
ExMat <- t(sapply(names(listSubsets), function(name) {
colMeans(subset(habitat, habitat$IdPE %in% listSubsets[[name]]))
}))
ExMat = ExMat[,-1]
ExMat <- t(sapply(names(listSubsets), function(name) {
colMeans(subset(habitat, habitat$IdPE %in% listSubsets[[name]]))
}))
ExMat = ExMat[,-1]
/!\\ sapply == tapply mais pour sortir une matrice et pas une liste /!\\
```{r}
boxplot(ExMat,
pch = 3, col = "darkred",
las = 2, log = "y")
labels
boxplot(ExMat,
pch = 3, col = "darkred",
las = 2, log = "y")
Des boxplots plus interresant :
1. Point d'écoute :
```{r}
plot(ExMat[,1:2],
pch = 3, col = "brown")
plot(ExMat[,1:2],
pch = 3, col = "brown")
2. Occupation du sol :
```{r}
boxplot(ExMat[,3:7],
pch = 3, col = "darkgreen")
boxplot(ExMat[,3:7],
pch = 3, col = "darkgreen")
3. Fragmentation :
```{r}
boxplot(ExMat[,8:11],
pch = 3, col = "salmon")
boxplot(ExMat[,8:11],
pch = 3, col = "salmon")
4. Topographie
```{r}
plot(ExMat[,12:13],
pch = 3, col = "black")
plot(ExMat[,12:13],
pch = 3, col = "black")
5. condition topographique
```{r}
plot(ExMat[,14:15],
pch = 3, col = "darkblue")
plot(ExMat[,14:15],
pch = 3, col = "darkblue")
6. Urbanisation
```{r}
boxplot(ExMat[,16],
pch = 3, col = "darkgray")
boxplot(ExMat[,16],
pch = 3, col = "darkgray")
####  ==> expliquer chacune des variables de l'espèce en fonction des variables de l'environnement
--> taille petite quand température haute, alimentation quand hydrométrie élevée
```{r}
dudi.pca()
dudi.pca()
####  ==> juxtaposition des tableaux :
tab1 --> subset = colnames(especes) + moyenne de chaque caractéristique des milieux
transposé de tab1 sur tab2
tab2 --> especes
####  ==> conclure :
####  ==> conclure :
knitr::opts_chunk$set(fig.align="center", fig.width=6, fig.height=6, fig.path="Figs/", echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
habitat = read.table("../data/habitat.tsv", sep = "\t",
stringsAsFactors = T, header = T, na.strings = T)
setwd("/run/media/amouroux/CORSAIR/cours/ADM/Projo/fr.univ-tlse3_ADM_project/scripts")
habitat = read.table("../data/habitat.tsv", sep = "\t",
stringsAsFactors = T, header = T, na.strings = T)
especes = read.table("../data/especes.tsv", sep = "\t",
stringsAsFactors = T, header = T, na.strings = T)
commu = read.table("../data/communautes.tsv", sep = "\t", stringsAsFactors = T, header = T, na.strings = T)
habitat = habitat[,-2:-3]
habitat[,2:3] = habitat[,2:3]/1e5 ;# habitat[15] = habitat[15]/1e3
name = colnames(habitat)
name[2:3] = c("long/1e5","lat/1e5");# name[15] = "prec/1e3"
colnames(habitat) = name
habitat = habitat[,-2:-3]
habitat[,2:3] = habitat[,2:3]/1e5 ;# habitat[15] = habitat[15]/1e3
name = colnames(habitat)
name[2:3] = c("long/1e5","lat/1e5");# name[15] = "prec/1e3"
colnames(habitat) = name
ANALYSE :
####  ==> extraire informations précédentes = subset par colonnes dont on extrait les numéros des localisations
Création des subsets de numéro de lieu ayant des Gem (Colombe.a.croissants)
listSubsets = data.frame(matrix(nrow = length(vectNom), ncol = length(habitat[1,]) - 3))
listSubsets <- list()
for (i in 1:length(vectNom)) {
especesActu = vectNom[i]
foosubset = subset(commu$IdPE, commu[[i+1]] == 1)
listSubsets[[especesActu]] <- foosubset
}
listSubsets$Gem
listSubsets$Gem
On a toutes les localisation de chaque espèce
Exemple d'appel pour les localisation de Gem :
####  ==> moyenne des données sur l'habitat pour chaque colonne du subset (espèces)
Pour se donner une idée de vers ou on vas, nous allons regarder chaque moyenne de variables
```{r}
par(mfrow = c(1,1))
ExGem = colMeans(subset(habitat, habitat$IdPE %in% listSubsets$Gem))
plot(ExGem[-1])
par(mfrow = c(1,1))
ExGem = colMeans(subset(habitat, habitat$IdPE %in% listSubsets$Gem))
plot(ExGem[-1])
Généraliser par une boucle tapply :
```{r}
ExMat <- t(sapply(names(listSubsets), function(name) {
colMeans(subset(habitat, habitat$IdPE %in% listSubsets[[name]]))
}))
ExMat = ExMat[,-1]
ExMat <- t(sapply(names(listSubsets), function(name) {
colMeans(subset(habitat, habitat$IdPE %in% listSubsets[[name]]))
}))
ExMat = ExMat[,-1]
/!\\ sapply == tapply mais pour sortir une matrice et pas une liste /!\\
```{r}
boxplot(ExMat,
pch = 3, col = "darkred",
las = 2, log = "y")
labels
boxplot(ExMat,
pch = 3, col = "darkred",
las = 2, log = "y")
ExMat <- t(sapply(names(listSubsets), function(name) {
colMeans(subset(habitat, habitat$IdPE %in% listSubsets[[name]]))
}))
par(mfrow = c(1,1))
ExGem = colMeans(subset(habitat, habitat$IdPE %in% listSubsets$Gem))
vectNom = names(commu[2:17])
listSubsets = data.frame(matrix(nrow = length(vectNom), ncol = length(habitat[1,]) - 3))
listSubsets <- list()
for (i in 1:length(vectNom)) {
especesActu = vectNom[i]
foosubset = subset(commu$IdPE, commu[[i+1]] == 1)
listSubsets[[especesActu]] <- foosubset
}
listSubsets = data.frame(matrix(nrow = length(vectNom), ncol = length(habitat[1,]) - 3))
for (i in 1:length(vectNom)) {
especesActu = vectNom[i]
foosubset = subset(commu$IdPE, commu[[i+1]] == 1)
listSubsets[[especesActu]] <- foosubset
}
vectNom = names(commu[2:17])
listSubsets = data.frame(matrix(nrow = length(vectNom), ncol = length(habitat[1,]) - 3))
for (i in 1:length(vectNom)) {
especesActu = vectNom[i]
foosubset = subset(commu$IdPE, commu[[i+1]] == 1)
listSubsets[[especesActu]] <- foosubset
}
listSubsets$Gem
plot(ExMat[,1:2],
pch = 3, col = "brown")
ExGem = colMeans(subset(habitat, habitat$IdPE %in% listSubsets$Gem))
# Chunk 1
knitr::opts_chunk$set(fig.align="center", fig.width=6, fig.height=6, fig.path="Figs/", echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
habitat = read.table("../data/habitat.tsv", sep = "\t",
stringsAsFactors = T, header = T, na.strings = T)
especes = read.table("../data/especes.tsv", sep = "\t",
stringsAsFactors = T, header = T, na.strings = T)
commu = read.table("../data/communautes.tsv", sep = "\t", stringsAsFactors = T, header = T, na.strings = T)
habitat = habitat[,-2:-3]
habitat[,2:3] = habitat[,2:3]/1e5 ;# habitat[15] = habitat[15]/1e3
name = colnames(habitat)
name[2:3] = c("long/1e5","lat/1e5");# name[15] = "prec/1e3"
colnames(habitat) = name
habitat = habitat[,-2:-3]
habitat[,2:3] = habitat[,2:3]/1e5 ;# habitat[15] = habitat[15]/1e3
name = colnames(habitat)
name[2:3] = c("long/1e5","lat/1e5");# name[15] = "prec/1e3"
colnames(habitat) = name
ANALYSE :
####  ==> extraire informations précédentes = subset par colonnes dont on extrait les numéros des localisations
Création des subsets de numéro de lieu ayant des Gem (Colombe.a.croissants)
listSubsets = data.frame(matrix(nrow = length(vectNom), ncol = length(habitat[1,]) - 3))
for (i in 1:length(vectNom)) {
especesActu = vectNom[i]
foosubset = subset(commu$IdPE, commu[[i+1]] == 1)
listSubsets[[especesActu]] <- foosubset
}
listSubsets$Gem
listSubsets$Gem
On a toutes les localisation de chaque espèce
Exemple d'appel pour les localisation de Gem :
####  ==> moyenne des données sur l'habitat pour chaque colonne du subset (espèces)
Pour se donner une idée de vers ou on vas, nous allons regarder chaque moyenne de variables
```{r}
par(mfrow = c(1,1))
ExGem = colMeans(subset(habitat, habitat$IdPE %in% listSubsets$Gem))
plot(ExGem[-1])
par(mfrow = c(1,1))
ExGem = colMeans(subset(habitat, habitat$IdPE %in% listSubsets$Gem))
plot(ExGem[-1])
Généraliser par une boucle tapply :
```{r}
ExMat <- t(sapply(names(listSubsets), function(name) {
colMeans(subset(habitat, habitat$IdPE %in% listSubsets[[name]]))
}))
# Chunk 1
knitr::opts_chunk$set(fig.align="center", fig.width=6, fig.height=6, fig.path="Figs/", echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
```{r, include= F}
======================= QUESTION 2 =======================
